<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="author" content="stephband">
    <meta name="description" content="Documentation for Fn. A library of functions, observers and streams, published as ES6 modules.">
    <meta name="viewport" content="width=device-width">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@stephband">
    <meta property="og:url" content="http://stephen.band/fn/">
    <meta property="og:title" content="Fn">
    <meta property="og:description" content="A library of functions, observers and streams, published as ES6 modules.">
    <meta property="og:image" content="">

    <title>Fn</title>

    <script title="load">
    document.documentElement.className += ' js content-loading loading';
    window.addEventListener('DOMContentLoaded', () => document.documentElement.classList.remove('content-loading'));
    // Wait for other load handlers to run first - Bolt does a few things on
    // load (eg. data-targetable scrolls) and we want them to run before the loading
    // class is removed
    window.addEventListener('load', () => window.requestAnimationFrame(() => document.documentElement.classList.remove('loading')));
    window.DEBUG = true;
    </script>

    <link rel="stylesheet" href="../../bolt/module.css" />
    <link rel="stylesheet" href="../../literal/module.css" />
    <link rel="icon" type="image/png" href="images/logo-32x32.png" sizes="32x32" />

    <style>
    :root {
        background-color: #e2e8ea;
    }

    body {
        padding: 1rem;
    }

    .process-grid {
        grid-auto-columns: 150px;
    }

    .momentary-button,
    .momentary-button:focus,
    .momentary-button:hover {
        border: 1px solid currentcolor;
        background: white;
        transition-timing-function: ease-out;
        transition-duration: 0.18s, 0.18s, 0.18s, 0.18s;
    }

    .momentary-button.on,
    .momentary-button.on:focus,
    .momentary-button.on:hover {
        color: white;
        background: black;
        transition-timing-function: linear;
        transition-duration: 0.024s, 0.024s, 0.024s, 0.024s;
    }

    .network-block > .grid {
        --x-gap: 24px;
    }

    .network-block > .grid > li {
        position: relative;
        z-index: 2;
    }

    .network-block > .layer {
        position: absolute;
        z-index: 1;
    }

    .read-output {
        font-size: 0.75rem;
        display: block;
        padding: 0.25rem;
        white-space: nowrap;
        background-color: white;
        border: 1px solid currentcolor !important;
        border-radius: 0.1875rem;
        width: 100%;
    }

    .input,
    .output {
        width: 0.4375rem;
        height: 0.4375rem;
        min-width: 0;
        min-height: 0;
        max-width: 0.4375rem;
        max-height: 0.4375rem;
        padding: 0;
        border-width: 0;
        margin-left: -0.25rem;
        border-radius: 50%;
        background-color: #aa7722;
    }

    .output {
        margin-left: auto;
        margin-right: -0.25rem;
    }

    .output:not(.connected)::before,
    .output:not(.connected)::after {
        content: '';
        position: absolute;
        /*opacity: 0;*/
        visibility: hidden;
        background-color: #aa7722;
        transition:
            visibility 0.3s linear 0.4s,
            transform 0.3s ease-in 0.4s,
            background-color 0.3s ease-in 0.4s;
    }

    .output:not(.connected)::after  {
        content: '+';
    }

    .output::before {
        left: 0.3125rem;
        top: 0.15625rem;
        width: 1.875rem;
        height: 0.125rem;
        transform: translate(0, 0) scale(0.2333333, 0.2333333);
        transform-origin: 0 0.0625rem;
        background-color: #aa7722;
    }

    .output::after {
        font-size: 1.25rem;
        text-align: center;
        line-height: 1.625rem;
        left: 1.375rem;
        top: -0.71875rem;
        width: 1.875rem;
        height: 1.875rem;
        transform: translate(-1.375rem, 0) scale(0.2333333, 0.2333333);
        transform-origin: 0 0.9375rem;
        color: #aa7722;
        border-radius: 50%;
        border: 2px solid #aa7722;
    }

    .process-block {
        border: 1px solid #aa7722;
        border-radius: 0.25rem;
        background-color: #f2efea;
    }

    .process-block:hover > .output::before,
    .process-block:focus > .output::before,
    .process-block:hover > .output::after,
    .process-block:focus > .output::after {
        /*opacity: 1;*/
        visibility: visible;
        transform: translate(0, 0) scale(1, 1);
        transition:
            visibility 0.12s linear 0s,
            transform 0.12s ease-out 0s,
            background-color 0.12s ease-out 0s;
    }

    .process-block:hover > .output::after,
    .process-block:focus > .output::after {
        background-color: #f2efea;
    }

    li > pre {
        padding-left: 0.5rem;
        padding-right: 0.5rem;
    }

    li > .input,
    li > .output {
        position: absolute;
        top: 9px;
        margin-top: 0;
        z-index: 4;
    }

    li > .input {
        left: 0;
    }

    li > .output {
        right: 0;
    }

    .setting {
        position: relative;
        padding-left: 0.5rem;
        padding-right: 0.5rem;
    }

    .setting > [type] {
        margin-top: 0;
    }

    .setting > .input {
        position: absolute;
        top: 19px;
        left: 0;
        margin-top: 0;
        z-index: 4;
        opacity: 0;
        transition: opacity 0.3s linear;
    }

    li:hover > .setting > .input,
    .setting > .input.connected {
        opacity: 1;
    }

    .setting + .setting {
        margin-top: 0;
    }
    </style>

    <template id="input-node-template">
        <button type="button" class="output" name="route" value="${ data.id }" id="network-node-${ data.id }-output"></button>
    </template>

    <template id="ui-node-template">
        <button type="button" class="output" name="route" value="${ data.id }" id="network-node-${ data.id }-output"></button>

        <button type="button" class="momentary-button button" name="state" value="${ data.data.value }">
            ${
                events('mousedown', element).each((e) => {
                    this.data.stream.push([e.timeStamp / 1000, parseFloat(element.value), 0]);
                    element.classList.add('on');
                }),

                events('mouseup', element).each((e) => {
                    this.data.stream.push([e.timeStamp / 1000, 0, 0]);
                    element.classList.remove('on');
                }),

                'Momentary'
            }
        </button>

        <button type="button" class="momentary-button button" name="state" value="${ data.data.value }">
            ${
                this.state = false,
                events('mousedown', element).each((e) => {
                    this.data.stream.push([e.timeStamp / 1000, this.state ? 0 : parseFloat(element.value), 0]);
                    this.state = !this.state;
                    element.classList[this.state ? 'add' : 'remove']('on');
                }),
                'Toggle'
            }
        </button>

        <button type="button" class="momentary-button button" name="state" value="${ data.data.value }">
            ${
                events('mousedown', element).each((e) => {
                    this.data.stream.push([e.timeStamp / 1000, parseFloat(element.value), 0]);
                    element.classList.add('on');
                    requestAnimationFrame(() =>
                        requestAnimationFrame(() =>
                            element.classList.remove('on')));
                }),
                'Hit'
            }
        </button>

        <label>Value</label>
        <input type="range" name="state" value="${ data.data.value }" min="${ data.data.min || 0 }" max="${ data.data.max || 1 }" step="${ data.data.step || 'any' }" data-events="${
            events('input', element).each((e) => this.data.stream.push([e.timeStamp / 1000, parseFloat(element.value), 0])),
            ''
        }" />
    </template>

    <template id="filter-node-template">
        ${ print(this, data.data) }
        <div class="input" id="network-node-${ data.id }-input" title="Input"></div>
        <button type="button" class="output" name="route" value="${ data.id }" id="network-node-${ data.id }-output"></button>
    </template>

    <template id="add-map-template">
        <pre>${ data.data.value.type }: ${ data.data.value.data.value.toPrecision(3) }</pre>
        <div class="setting">
            <div class="input" id="network-node-${ data.id }-value.data.value" title="Value ${ data.data.value.type }"></div>
            <input type="range" value="${ data.data.value.data.value }" name="min" min="-12" max="12" />
        </div>
    </template>

    <template id="multiply-map-template">
        <pre>${ data.data.value.type }: ${ data.data.value.data.value.toPrecision(3) }</pre>
        <div class="setting">
            <div class="input" id="network-node-${ data.id }-value.data.value" title="Value ${ data.data.value.type }"></div>
            <input type="range" value="${ data.data.value.data.value }" name="min" min="0.0625" max="16" />
        </div>
    </template>

    <template id="clamp-map-template">
        <pre>${ data.data.value.type }: ${ data.data.value.data.min.toPrecision(3) } - ${ data.data.value.data.max.toPrecision(3) }</pre>
        <div class="setting">
            <div class="input" id="network-node-${ data.id }-value.data.min" title="Value ${ data.data.value.type } min"></div>
            <input type="range" value="${ data.data.value.data.min }" name="min" min="0" max="2" step="any" />
        </div>
        <div class="setting">
            <div class="input" id="network-node-${ data.id }-value.data.max" title="Value ${ data.data.value.type } max"></div>
            <input type="range" value="${ data.data.value.data.max }" name="max" min="0" max="2" step="any" />
        </div>
    </template>

    <template id="map-node-template">
        ${ events('input', element).each((e) => data.data.value.data[e.target.name] = parseFloat(e.target.value)), print(this, data.data) }
        <div class="input" id="network-node-${ data.id }-input" title="Input"></div>
        <button type="button" class="output" name="route" value="${ data.id }" id="network-node-${ data.id }-output"></button>
        <select value="${ data.data.value.type }">
            <option value="add">Add</option>
            <option value="clamp">Clamp</option>
            <option value="multiply">Multiply</option>
        </select>
        ${ include('#' + data.data.value.type + '-map-template', data) }
    </template>

    <template id="distribute-node-template">
        <div class="input" id="network-node-${ data.id }-input" title="Input"></div>
        <button type="button" class="output" name="route" value="${ data.id }" id="network-node-${ data.id }-output"></button>
    </template>

    <template id="set-node-template">
        ${ print(this, data.data) }
    </template>

    <template id="route-node-template">
        <div class="input" id="network-node-${ data.id }-input" title="Input"></div>

        <div class="setting">
            <label>Target</label>
            <input type="text" value="${ data.data.id }" name="id" />
        </div>

        <div class="setting">
            <label>Property</label>
            <input type="text" value="${ data.data.name }" name="name" />
        </div>
    </template>

    <template id="log-node-template">
        ${ print(this, data) }
    </template>

    <template id="print-node-template">
        <output class="read-output">${ this.data.stream.map((event) => event[0].toFixed(3) + ', ' + event[1].toPrecision(4) + ', ' + event[2]) }</output>
        <div class="input" id="network-node-${ data.id }-input" title="Input"></div>
    </template>

    <template id="node-template">
        <li class="y-start process-block block ${ 'y' + data.row }">
            <pre style="font-size: 0.875rem;">${ data.node.type }</pre>
            ${ include('#' + data.node.type + '-node-template', data.node) }
        </li>
    </template>

    <template id="network-template">
        <section class="network-block block">
            <ul class="process-grid grid list">
                ${
                    events({ type: 'click', select: '[name="route"]' }, element)
                    .each((e) => {
                        const id   = parseInt(e.target.value, 10);
                        const node = this.data.nodes.find((node) => node.id === id);
                        //console.log('Route', id, node);
                        // Todo: Select an input or create a new node.
                        // Inputs glow to show acquiescence. Create pane appears
                        // in next grid slot with choice of node type to create.
                        this.data.create('map', { value: { type: 'add', data: { value: 1 }}}, node);
                        notify('nodes', this.data);
                    }),

                    this.i = 0,
                    this.terminals = data.nodes.filter((node) => node.type === 'distribute' || node.type === 'route' || node.type === 'print'),
                    // Decide which rows nodes should appear on
                    this.rows = this.terminals.reduce((rows, node) => {
                        const row = ++this.i;
                        rows[node.id] = row;

                        let sourceId = node.id;
                        while (
                            (sourceId = this.data.findSource(sourceId)) !== undefined
                            && !this.terminals.find((node) => node.id === sourceId)
                        ) {
                            rows[sourceId] = row;
                        }
                        return rows;
                    }, {}),

                    data.nodes
                    .filter((node) => node.type !== 'set')
                    .map((node) => include('#node-template', { node, row: this.rows[node.id] }))
                }
            </ul>
            <canvas class="layer">
                ${
                    this.ctx = element.getContext('2d'),

                    merge(new Promise((resolve) => requestAnimationFrame(resolve)), events('resize', window)).each(() => {
                        element.width = element.clientWidth * 2;
                        element.height = element.clientHeight * 2;
                        const e = element.getBoundingClientRect();

                        data.routes.forEach((n, i) => {
                            if (i % 2 === 0) { return; }

                            const src = document.getElementById('network-node-' + data.routes[i - 1] + '-output');
                            const s = src.getBoundingClientRect();

                            const node = data.nodes.find((node) => node.id === n);

                            const trg = node.type === 'set' ?
                                document.getElementById('network-node-' + node.data.target + '-' + node.data.name) :
                                document.getElementById('network-node-' + n + '-input') ;

                            src.classList.add('connected');
                            trg.classList.add('connected');

                            const t = trg.getBoundingClientRect();

                            this.ctx.lineWidth   = '2';
                            this.ctx.lineCap     = 'round';
                            this.ctx.strokeStyle = '#aa7722';
                            this.ctx.beginPath();
                            this.ctx.moveTo(2 * (s.x + 0.5 * s.width - e.x), 2 * (s.y + 0.5 * s.height - e.y));
                            this.ctx.lineTo(2 * (t.x + 0.5 * t.width - e.x), node.type === 'set' ? 2 * (t.y + 0.5 * t.height - e.y) : 2 * (t.y + 0.5 * t.height - e.y));
                            this.ctx.stroke();
                            this.ctx.closePath();
                        });
                    })
                }
            </canvas>
        </section>
    </template>
</head>

<body class="">
    <!--header class="" id="header">
        <h1 class="doctext-01">Network</h1>
    </header-->

    <include-literal src="#network-template" id="ui"></include-literal>

    <!-- Document interactivity -->
    <script type="module">
        import Network from './control-network.js';
        import '../../literal/module.js';

        const network = new Network([
            { id: 0, type: 'ui', data: { value: 1, min: 0, max: 3, step: 'any' } },

            { id: 2, type: 'map', data: {
                value: { type: 'clamp', data: { min: 1, max: 2 } }
            }},

            { id: 3, type: 'distribute' },

            { id: 1, type: 'filter', data: {
                type:  { type: 'in', data: ['linear'] },
                value: { type: 'minmax', data: { min: 0.5, max: 2 } }
            }},

            { id: 4, type: 'map', data: {
                value: { type: 'add', data: { value: 5 } }
            }},

            { id: 5, type: 'set', data: {
                target: 2,
                name: 'value.data.max'
            }},

            { id: 6, type: 'route', data: {
                id: 100,
                name: 'something'
            }},

            { id: 7, type: 'print', data: 'output' }
        ], [
            0, 2,
            2, 3,
            3, 1,
            1, 5,
            3, 4,
            3, 7,
            4, 6,
        ]);

        document.getElementById('ui').data = network;

        console.log(network);
        window.network = network;
    </script>

</body></html>
