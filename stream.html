<!DOCTYPE html>
<!-- Literal template "/Users/stephband/Sites/slide-show/index.html.literal" -->

<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="author" content="Stephen Band" />
    <meta name="description" content="Documentation for <slide-show>. A scroll-snapping slideshow/carousel, implemented as the custom element <slide-show>." />
    <meta name="viewport" content="width=device-width" />

    <title>Stream</title>

    <script title="load">
        document.documentElement.className += ' js loading';
        // window.addEventListener('DOMContentLoaded', () => document.documentElement.classList.remove('content-loading'));
        // Wait for other load handlers to run first - Bolt does a few things on
        // load (eg. targetable scrolls) and we want them to run before the loading
        // class is removed
        window.addEventListener('load', () => window.requestAnimationFrame(() => document.documentElement.classList.remove('loading')));
    </script>


    <script title="debug">
        window.DEBUG = true;
    </script>
</head>

<body>
    <script type="module">
        window.DEBUG = true;

        //import Stream from './modules/stream.js';
        //import './test/stream.js';
        //import './test/observer.js';
        //window.Stream = Stream;

        import run      from './modules/test.js';
        import overload from './modules/overload.js';
        import toType   from './modules/to-type.js';

        const assign     = Object.assign;
        const create     = Object.create;
        const $listeners = Symbol('listeners');

        const call = overload(toType, {
            function: (fn) => fn(),
            object:   (object) => object.stop()
        });

/*
        function pipe(stream, output) {
            //if (stream[0]) {
            //    throw new Error('Stream: cannot .pipe() a unicast stream more than once');
            //}
            stream[0] = output;
            output.input = stream;
            return output;
        }
*/

        function unpipe(stream, output) {
            let n = -1;
            let o;

            // Find stream[n] that matches `output`
            while (stream[++n] && stream[n] !== output);

            if (window.DEBUG && !stream[n]) {
                throw new Error('Stream: Cannot unpipe(), `output`, not an output of `stream`');
            }

            // Stop responding to stop() and start() on output
            output.input = undefined;

            // Decrement output n of higher number outputs
            while (stream[n++]) {
                stream[n - 1] = stream[n];
            }

            return output;
        }

        function stop(stream) {
            // Check and set status
            if (stream.status === 'done') {
                if (window.DEBUG) { throw new Error('Stream: cannot stop() stream that is done'); }
                return stream;
            }

            stream.status = 'done';

            // If stream has not yet been piped, we don't call done() functions
            // for streams that have not been consumed. The problem with
            // stream[0] on its own is that it's `false` for an Each stream
            // or other consumer. The way to identify a consumer is that it
            // does not have a .pipe().
            if (!stream[0] && !!stream.pipe) { return stream; }

            // Call done functions and listeners
            const listeners = stream[$listeners];
            stream[$listeners] = undefined;

            if (listeners) {
                listeners.forEach(call);
            }

            // Unpiping output 0 decrements other outputs, so this loops through
            // all outputs
            while (stream[0]) {
                stop(unpipe(stream, stream[0]));
            }

            return stream;
        }

        function Stream(pipeable) {
            // A pipeable must have .pipe() and .stop() methods.
            this.input = pipeable;
        }

        assign(Stream, {
            of: function() {
                return new Stream(arguments);
            },

            from: function(pipeable) {
                return new Stream(pipeable);
            }
        });

        assign(Stream.prototype, {
            push: function(value) {
                return this[0] && this[0].push(value);
            },

            pipe: function(output) {
                if (this[0]) {
                    throw new Error('Stream: cannot .pipe() a unicast stream more than once');
                }

                // Add to outputs
                this[0] = output;

                // Tell previous in chain to start pipe
                this.input.pipe(this);
                return output;
            },

            each: function(fn) {
                return this.pipe(new Each(this, fn));
            },

            done: function(listener) {
                // Is stream already stopped? Call listener immediately.
                if (this.status === 'done') {
                    call(listener);
                    return this;
                }

                const listeners = this[$listeners] || (this[$listeners] = []);
                listeners.push(listener);
                return this;
            },

            broadcast: function(options) {
                return this.pipe(new BroadcastStream(this, options));
            },

            map: function(fn) {
                //return pipe(this, new Map(this, fn));
                //return this.pipe(new Map(this, fn));
                return new Map(this, fn);
            },

            start: function() {
                if (this.status === 'done') { return this; }
                this.input.start.apply(this.input, arguments);
                return this;
            },

            stop: function() {
                // Check status
                if (this.status === 'done') {
                    return this;
                }

                // Does input have more than 1 output? ie, is it a multicast or
                // broadcast stream? Don't stop it, stop `this`. This also
                // unpipes it from the input stream.
                if (this.input[1]) {
                    return stop(unpipe(this.input, this));
                }

                // Stop input
                // Do we must guard against this?
                //if (!this.input[0]) {
                //    this.input[0] = this;
                //}

                this.input.stop.apply(this.input, arguments);
                return this;
            }
        });


        /* Each() */

        function Each(input, fn) {
            this.input = input;
            this.push  = fn;
        }

        Each.prototype = assign(create(Stream.prototype), {
            // Each is a consumer
            pipe: null
        });


        /* Map() */

        function Map(input, fn) {
            this.input = input;
            this.fn    = fn;
        }

        Map.prototype = assign(create(Stream.prototype), {
            push: function map(value) {
                const fn     = this.fn;
                const result = fn(value);
                // Reject undefined, return false... why?
                return result === undefined || !this[0] ?
                    false :
                    this[0].push(result) ;
            }
        });


        import nothing from './modules/nothing.js';
        //import Stream  from './modules/stream.js';

        //const assign = Object.assign;
        //const create = Object.create;


        /*
        BroadcastStream(pipeable, options)
        A BroadcastStream may be piped to multiple outputs. The options object has
        the optional properties:

        ```js
        {
            // Remember and send the latest value to new pipes
            memory: true,

            // Start the stream immediately and keep it alive after all pipes are stopped
            hot:    true
        }
        ```
        */

        function disconnect(stream, output) {
            if (stream[1]) {
                let n = -1;
                while (stream[++n] && stream[n] !== output);
                while (stream[n++]) { stream[n - 1] = stream[n]; }
            }
            else {
                stream.stop();
            }
        }

        export default function BroadcastStream(pipeable, options) {
            //Stream.apply(this, arguments);
            this.input = pipeable;

            // Mark this stream as a memory stream
            this.memory = !!(options && options.memory);

            // Open the stream immediately and keep it live even without outputs by
            // sending output 0 to nothing. It can now only be stopped by explicitly
            // calling .stop() on it, and not by stopping child streams.
            if (options && options.hot) {
                this.pipe(nothing);
            }
        }

        BroadcastStream.prototype = assign(create(Stream.prototype), {
            push: function(value) {
                // Reject undefined
                if (value === undefined) { return; }

                // If this is a memory stream keep value
                if (this.memory) {
                    this.value = value;
                }

                let n = -1;
                while (this[++n]) {
                    this[n].push(value);
                }
            },

            pipe: function(output) {
                let n = -1;
                while (this[++n]);

                // If this is a memory stream and this is the first output, flush the
                // pipe. But we don't have any outputs yet! I know, but the latest value
                // is remembered and it gets pushed to output below.
                if (this.memory && n === 0) {
            //        this.input.pipe(this);
                }

                this[n] = output;
                output.input = this;

            //    output.done(() => disconnect(this, output));

                // If stream has value already, it is a memory stream
                if (this.value !== undefined) {
                    output.push(this.value);
                }

                // If not a memory stream and this is the first output start the pipeline
                if (!this.memory && n === 0) {
            //        this.input.pipe(this);
                }

                return output;
            }
        });



        // ------


        run('Stream...each()',
        ['.pipe()', 'a', 'b', 1, 2],
        function(test, done) {
            const stream1 = new Stream({
                pipe: function(stream) {
                    test('.pipe()')
                    // Pushes nothing
                    this.stream = stream;
                },

                stop: function(a, b) {
                    // No need to check for .status in a pipeable, the stream
                    // does that before calling it
                    test(a);
                    test(b);
                    // A pipeable must stop the stream using imported stop()
                    stop(this.stream);
                }
            });

            setTimeout(() => {
                stream1
                .each(test)
                .done(() => test(1))
                .done(() => test(2))
                .stop('a', 'b');
                done();
            }, 200);
        });

        run('Stream.stop()',
        [0, 'a', 'b', 1, 'done', undefined, 2, 'done', 'done', 3, 4],
        function(test, done) {
            const stream1 = new Stream({
                pipe: function(stream) {
                    this[0] = stream;
                },

                stop: function(a, b) {
                    // No need to check for .status here, the stream does that
                    test(a);
                    test(b);
                    // A pipeable must stop the stream (if it is not itself a
                    // stream, which it isn't here, it's just an object)
                    stop(this[0]);
                    return this;
                }
            });

            const stream2 = stream1.map((a) => a);

            stream1.done((v) => (test(1), test(stream1.status), test(stream2.status)));
            stream2.done((v) => (test(2), test(stream1.status), test(stream2.status)));
            stream2.each(test);
            stream1.push(0);
            stream2.stop('a', 'b');
            stream1.push(5);
            stream2.done((v) => test(3));
            stream1.done((v) => test(4));

            // It is permitted to stop more than once, if status is not done. In
            // this scenario the head stop() may not have stopped the stream,
            // which may be open for rescheduling
            stream1.stop('good');
            stream1.stop('bye');

            done();
        });

        run('Stream.each().start(time).stop(time)',
        ['.pipe()', '.start()', '.stop()', 'done'],
        function(test, done) {
            // Make a simple frame stream
            function start(stream) {
                stream.frame = requestAnimationFrame((time) => {
                    // Poll frames until time is beyond stream startTime
                    if (time < stream.startTime) {
                        start(stream);
                        return;
                    }

                    play(stream, time);
                });
            }

            function play(stream, time) {
                // Push the frame
                stream.push(++stream.count);
                if (stream.stopTime <= time) {
                    stop(stream);
                    return;
                }
                stream.frame = requestAnimationFrame((time) => play(stream, time));
            }

            const now = performance.now();
            const fd = 16.666666666667;

            const stream1 = new Stream({
                pipe: function(stream) {
                    test('.pipe()');
                    this.stream = stream;
                    stream.count = 0;
                    if (this.startTime !== undefined) {
                        stream.startTime = this.startTime;
                        stream.stopTime  = this.stopTime;
                        start(stream);
                    }
                },

                start: function(time) {
                    test('.start()');
                    if (this.stream) {
                        this.stream.startTime = time;
                        start(this.stream);
                    }
                    else {
                        this.startTime = time;
                    }
                },

                stop: function(time) {
                    test('.stop()');
                    if (this.stream) {
                        this.stream.stopTime = time;
                    }
                    else {
                        this.stopTime = time;
                    }
                }
            })
            .each((count) => console.log('frame', count))
            .start(now + 200)
            .stop(now + 200 + 3 * fd)
            .done(() => test('done'))
            .done(done);
        });

        run('Stream.start(time).stop(time).each()',
        ['.start()', '.stop()', '.pipe()', 'done'],
        function(test, done) {
            // Make a simple frame stream
            function start(stream) {
                stream.frame = requestAnimationFrame((time) => {
                    // Poll frames until time is beyond stream startTime
                    if (time < stream.startTime) {
                        start(stream);
                        return;
                    }

                    play(stream, time);
                });
            }

            function play(stream, time) {
                // Push the frame
                stream.push(++stream.count);
                if (stream.stopTime <= time) {
                    stop(stream);
                    return;
                }
                stream.frame = requestAnimationFrame((time) => play(stream, time));
            }

            const now = performance.now();
            const fd = 16.666666666667;

            const stream1 = new Stream({
                pipe: function(stream) {
                    test('.pipe()');
                    this.stream = stream;
                    stream.count = 0;
                    if (this.startTime !== undefined) {
                        stream.startTime = this.startTime;
                        stream.stopTime  = this.stopTime;
                        start(stream);
                    }
                },

                start: function(time) {
                    test('.start()');
                    if (this.stream) {
                        this.stream.startTime = time;
                        start(this.stream);
                    }
                    else {
                        this.startTime = time;
                    }
                },

                stop: function(time) {
                    test('.stop()');
                    if (this.stream) {
                        this.stream.stopTime = time;
                    }
                    else {
                        this.stopTime = time;
                    }
                }
            })
            .start(now + 200)
            .stop(now + 200 + 3 * fd)
            .each((count) => console.log('frame', count))
            .done(() => test('done'))
            .done(done);
        });


        run('SubStream.stop() unconsumed streams', [
            'a', 'b',
            //1, 'done', undefined,
            //2, 'done', undefined,
            //3, 'done', 'done',
            //4, 'done', 'done',
            'good',
            'bye'
        ], function(test, done) {
            function SubStream() {}

            SubStream.prototype = assign(create(Stream.prototype), {
                // pipe not called for this test, as stream is never consumed
                pipe: test,

                stop: function(a, b) {
                    // Must check for status, someone may call .stop() directly on
                    // substream instance
                    test(a);
                    if (this.status === 'done') { return this; }
                    test(b);
                    stop(this);
                    return this;
                }
            });

            // ------

            const stream1 = new SubStream();
            // These console logs should never be seen
            const stream2 = stream1.map((a) => (console.log('a', a), a));
            const stream3 = stream2.map((b) => (console.log('b', b), a));

            // Unconsumed streams do not fire .done()
            stream1.done((v) => (test(1), test(stream1.status), test(stream2.status)));
            stream2.done((v) => (test(3), test(stream1.status), test(stream2.status)));
            stream2.done((v) => (test(4), test(stream1.status), test(stream2.status)));
            stream1.done((v) => (test(2), test(stream1.status), test(stream2.status)));
            stream3.stop('a', 'b');

            // It is permitted to stop more than once, although if stop has not
            // been delayed this has no effect because .status === 'done'.
            stream1.stop('good');
            stream1.stop('bye');

            // Should not be fired
            stream3.done(test);
            done();
        });

        run('SubStream.stop() delayed stop',
        [0, 'a', 'b', 'c', undefined, 'd', undefined, 1, 'done', undefined, 2, 'done', undefined, 3, 'done', 'done', 4, 'done', 'done', 5],
        function(test, done) {
            function SubStream() {}

            SubStream.prototype = assign(create(Stream.prototype), {
                pipe: function(output) {
                    // pipe must publish indexed outputs
                    this[0] = output;
                },

                stop: function(a, b) {
                    // Must check for status, someone may call .stop() directly on
                    // substream instance
                    test(a);
                    if (this.status === 'done') { return this; }
                    test(b);
                    // Delayed stop
                    setTimeout(() => {
                        if (this.status === 'done') { return this; }
                        stop(this);
                    }, 500);
                    return this;
                }
            });

            // ------

            const stream1 = new SubStream();
            const stream2 = stream1.map((a) => a);
            const stream3 = stream2.map((a) => a);

            stream1.done((v) => (test(1), test(stream1.status), test(stream2.status)));
            stream2.done((v) => (test(3), test(stream1.status), test(stream2.status)));
            stream2.done((v) => (test(4), test(stream1.status), test(stream2.status)));
            stream1.done((v) => (test(2), test(stream1.status), test(stream2.status)));

            stream3
            .each(test)
            .done((v) => test(5))
            .done(done);

            stream1.push(0);
            stream3.stop('a', 'b');

            // It is permitted to stop more than once, if status is not done. In
            // this scenario the head stop() may not have stopped the stream,
            // which may be open for rescheduling
            stream1.stop('c');
            stream1.stop('d');
        });

        run('SubStream.stop() delayed start???', [1], function(test, done) {
            function SubStream() {}

            SubStream.prototype = assign(create(Stream.prototype), {
                pipe: function(output) {
                    this[0] = output;
                },

                stop: function(a, b) {
                    // Must check for status
                    if (this.status === 'done') { return this; }
                    stop(this);
                    return this;
                }
            });

            // ------

            const stream1 = new SubStream();
            const stream2 = stream1.map((a) => a);
            stream1.push(0);
            stream2.each(test).done(done);

            setTimeout(() => {
                stream1.push(1);
                stream1.stop();
            }, 500)
        });

        run('Stream.broadcast().stop() to one stream',
        [1,2,3,'done',undefined,4,'done','done',5,6],
        function(test, done) {
            const stream1 = new Stream({
                pipe: function(output) {
                    this.mynameforoutput = output;
                },

                stop: function(a, b) {
                    // A pipeable must stop the stream on output 0,
                    // if it is not itself a stream
                    stop(this.mynameforoutput);
                }
            });

            const stream2 = stream1.broadcast();

            stream2.done((v) => (test(4), test(stream1.status), test(stream2.status)));
            stream1.done((v) => (test(3), test(stream1.status), test(stream2.status)));
            stream2.each(test);
            stream1.push(1);
            stream1.push(2);
            stream2.stop();
            stream2.done((v) => test(5));
            stream1.done((v) => test(6));

            done();
        });

        run('Stream.broadcast().stop() to multiple streams',
        [1,1,2,2,2,3,'done',undefined,4,'done','done',5,6,7,8,9],
        function(test, done) {
            const stream1 = new Stream({
                pipe: function(output) {
                    this.mynameforoutput = output;
                },

                stop: function(a, b) {
                    // A pipeable must stop the stream on output 0,
                    // if it is not itself a stream
                    stop(this.mynameforoutput);
                }
            });

            const stream2 = stream1.broadcast();

            stream2.done((v) => (test(4), test(stream1.status), test(stream2.status)));
            stream1.done((v) => (test(3), test(stream1.status), test(stream2.status)));
            stream2.each(test).done((v) => test(5));
            stream2.each(test).done((v) => test(6));
            stream1.push(1);
            stream2.each(test).done((v) => test(7));
            stream1.push(2);
            stream2.stop();
            // These fire synchronously because streams are stopped
            stream2.done((v) => test(8));
            stream1.done((v) => test(9));

            done();
        });
    /**/
    </script>
</body>
